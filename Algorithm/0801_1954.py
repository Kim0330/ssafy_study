T = int(input())

#우하좌상 순서! 델타배열을 만들때!
#     0  1  2  3  #인덱스
dr = [0, 1, 0, -1] #행방향 변화
dc = [1, 0, -1, 0] #열방향 변화
# dr[0] => 0방향으로 갔을 때 행번호의 변화량 우하좌상에서 0 은 뭐야? 우! 우방향으로 갔을때가된다.

for tc in range(1, T+1):
    N = int(input()) #달팽이 크기

    snail = [[0] * N for _ in range(N)] #0이 아니면 그 위치에 숫자를 놓은 적이 있다라는 뜻!

    d = 0 #현재 방향을 알고 있어야함!! 우하좌상의 0방향/ +1 하면 하 방향이 됨!
    r, c = 0,0
    for i in range(1, N * N +1):
        #r, c = 0, 0 #시작위치 근데 여기있으면 반복될때마다 0,0으로 바뀌니까 위치 바꿔줘야함!
        snail[r][c] = i
        #0,0 에서 0,1 로 가려면 어떻게 해야할까? 내가 가고있는 방!향!을 알고있어야 다음위치를 계산 할 수 있음!
        # 또한 현재 방향을 알고 있어야 다음 갈 위치를 알고 있음(위에 d,r,c 값을 줌)
        nr = r + dr[d]
        nc = c + dc[d]

        # 방향을 언제 바꿔야 할까?
        # 배열의 범위를 벗어났을때
        # 내가 이전에 놓은 숫자를 만났을때
        # 방향 바꿨으면 다음 위치 다시 계산산

        # nr과 nc의 자리는 바뀌어도 되지만 and 오류(F 이면 뒤에를 보지도 않고 F를 나타냄)로 인해 snail 구문은 무조건!!! nr 뒤에 적어야함!
        # snail[r][c] == 0라는 뜻은 값이 없다라는 뜻임!
        if 0 <= nr < N and 0 <= nc < N and snail[nr][nc] == 0:

        #그리고 위 사항에 해당되는 것은 새로운 것은 r,c에 할당해라 라는 뜻
            r, c = nr,nc

        #방향은 0 1 2 3 으로 가기때문에 3이 넘어가는 4일경우에는 0으로 돌아가라라는 뜻

        else:
            if d < 3:
                d += 1

            else:
                d = 0

            r = r + dr[d]
            c = c + dc[d]
    print(f"#{tc}")

    for r in range(N):
        print(*snail[r])





