for tc in range(1, 11):
    T = int(input())
    # input 값이 리스트니까 이렇게 두어도 되나?

    # 100번 도는 반복문 input으로 들어오면 문자열이 되기 때문에 가공을해줘야함!
    # 한줄씩 리스트를 읽고 그 리스트를 추가하겠다.
    # 예
    # 3 4 5
    # 5 6 7
    # 5 0 2 식으로
    # d = []
    # for j in range(100):
    #   new_lst= list(map(int, input().split()))
    #         d.append(new_lst)
    # 위에를 줄인게 아래임!! 이거 정확하게 이해하기!!
    new_list = [list(map(int, input().split())) for _ in range(100)]

    # 첫줄
    # rc 위치를 찾자 2 있는 곳
    # 마지막행 y[n-1]열을 돌면서 2를찾기 (9,0)(9,1).....
    # 내장함수 enumerate 사용함 99번째 행을 돌아가기 위해서
    # i행 j열 99열로 고정
    # 만약 i ==2 인곳을 찾았다면 자리 행열을 뽑아내기

    # enumerate를 쓰면 인덱스와 2가들어가 있는 값이 나옴
    for j, num in enumerate(new_list[99]):
        if num == 2:
            nj = j
            break
    # 위에 열값을 그대로 가져와서 반복문 시작하기
    # 현재위치를 표시
    # 우 좌  상
    # 0  1  2
    dr = [0, 0, -1]  # 행
    dc = [1, -1, 0]  # 열

    # d의 위치가 어떻게 되어야하지?
    # 좌랑 우가 있으면 우선적으로 가야하고 아래만 있으면 아래로만 가야함
    # (98,nj)에서 시작을 하고 싶은데 어떻게 해야하지?
    d = 0
    r, c = 98, nj
    # 오른쪽에 1이 있는지 없는지 먼저 보고, 있으면 쭉간다(0을 만나기 직전까지)
    # 1이 없다. 왼쪽을 본다. 있으면 쭉간다
    # 왼쪽에도 1이 없다 그러면 위로간다.

    # 2차원 자표계
    # 먼저 오른쪽으로 갈 수 있냐가 선행 그리고 1이 있냐 없냐이기에 0은 필요
    # 0<= c+dc[0] <= 99 오른쪽으로 가려고
    while r > 0:
        if 0 <= c + dc[0] <= 99 and new_list[r + dr[0]][c + dc[0]] == 1:
            r, c = r + dr[0], c + dc[0]
            # 반복문에서 false(값이 없음)를 만들어내는 조건문을 작성해야함
            # 만약 옆에 값이 없으면 false

            # while 옆 자체 탈출문을 적어줌 그래서 따로 탈출문을 적어줄 필요가 없음.
            # 1이 있을경우 1  1 1 1 0 을 가다가 오른쪽에 방이 있음에도 0 이면 false 가 나오기 때문에 다음으로 넘어감
            while 0 <= c + dc[0] <= 99 and new_list[r][c + dc[0]] == 1:
                r, c = r, c + dc[0]

        elif 0 <= c + dc[1] <= 99 and new_list[r + dr[1]][c + dc[1]] == 1:
            r, c = r + dr[1], c + dc[1]

            while 0 <= c + dc[1] <= 99 and new_list[r][c + dc[1]] == 1:
                r, c = r, c + dc[1]

        r -= 1

    print(f"#{tc} {c}")